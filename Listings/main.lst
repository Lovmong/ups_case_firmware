C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: G:\Keil_v5_c51v961\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) INCDIR(.\src;.\system) PRINT(.\List
                    -ings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*============================================================================
   2          
   3          
   4          STC8H1K08:
   5          
   6          
   7          
   8          
   9          
  10          ==============================================================================*/
  11          
  12          
  13          #include "stc8h.h"
  14          #include "intrins.h"
  15          
  16          #include "types.h"
  17          #include "delay.h"
  18          
  19          #include "btn.h"
  20          #include "rgb.h"
  21          #include "fan.h"
  22          #include "power.h"
  23          // #include "i2c.h"
  24          
  25          
  26          
  27          /* --- i2c data registers --- */
  28          #define I2C_SLAVE_ADDRESS 0x5A
  29          
  30          bit isda;                                       //设备地址标志
  31          bit isma;                                       //存储地址标志
  32          
  33          u8 addr;
  34          u8 i2c_buffer[] = {
  35              0, // 电池电压高位 mV
  36              0, // 电池电压低位 mV
  37              0, // 输出电流高位 mA
  38              0, // 输出电流低位 mA
  39              0, // Power_Source, 0 usb 供电，1 电池供电
  40              0, // CHG, 0 电池未充电， 1 正在充电
  41              0, // 风扇速度 0 ~ 100
  42              0, // PWM CCR1H
  43              0, // PWM CCR1H
  44          };
  45          
  46          u8 i2c_write_buffer[] = {
  47              0, // 风扇速度 0 ~ 100
  48          };
  49          
  50          
  51          const u8 rgb_styles[8][3] = {
  52              {0, 1, 1},
  53              {1, 0, 1},
  54              {1, 1, 0},
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 2   

  55              {0, 0, 0},
  56              {0, 0, 1},
  57              {0, 1, 0},
  58              {1, 0, 0},
  59              {1, 1, 1},
  60          };
  61          
  62          
  63          void I2CInit(u8 addr) {
  64   1          P1M0 &= ~0x30; P1M1 &= ~0x30;  // P1.4, P1.5 准双向口
  65   1      
  66   1          P_SW2 = 0x80;
  67   1      
  68   1          I2CCFG = 0x81;                              //使能I2C从机模式
  69   1          I2CSLADR = (addr << 1) & 0xff;              //设置从机设备地址寄存器I2CSLADR=0101_1010B
  70   1                                                      //设置从机设备地址寄存器I2CSLADR=0101_1010B
  71   1                                                      //即I2CSLADR[7:1]=010_1101B,MA=0B。
  72   1                                                      //由于MA为0,主机发送的的设备地址必须与
  73   1                                                      //I2CSLADR[7:1]相同才能访问此I2C从机设备。
  74   1                                                      //主机若需要写数据则要发送5AH(0101_1010B)
  75   1                                                      //主机若需要读数据则要发送5BH(0101_1011B)
  76   1          I2CSLST = 0x00;
  77   1          I2CSLCR = 0x78;                             //使能从机模式中断
  78   1          EA = 1;
  79   1      
  80   1          isda = 1;                                   //用户变量初始化
  81   1          isma = 1;
  82   1          addr = 0;
  83   1          I2CTXD = i2c_buffer[addr];
  84   1      }
  85          
  86          
  87          /* ------------------------------------------------------------
  88          ADC_CONTR: ADC_CONTR ADC 控制寄存器
  89                  7           6            5          4          3 2 1 0
  90                  ADC_POWER  ADC_START   ADC_FLAG    ADC_EPWMT   ADC_CHS[3:0]
  91          
  92          ADC_RES： ADC 转换结果高位寄存器
  93          ADC_RESL： ADC 转换结果低位寄存器
  94          ADCCFG：ADC 配置寄存器
  95                  5
  96                 RESFMT
  97          ADCTIM: ADC 时序控制寄存器
  98          
  99          ------------------------------------------------------------ */
 100          u16 BatteryVoltageRead() {
 101   1          u16 adc_val = 0;
 102   1      
 103   1          // 使能 adc
 104   1          P3M0 &= ~0x02; P3M1 &= ~0x02; // P3.1 准双向口
 105   1          P_SW2 |= 0x80;
 106   1          ADCTIM = 0x3f;                              //设置ADC内部时序
 107   1          // P_SW2 &= 0x7f;
 108   1          ADCCFG = 0x0f;                              //设置ADC时钟为系统时钟/2/16
 109   1          ADCCFG |= 0x20;                             // RESFMT 结果右对齐
 110   1          ADC_CONTR = 0x80;                           //ADC_POWER, 使能ADC模块 
 111   1          ADC_CONTR |= 0x09;                          // ADC_9, 选择通道9
 112   1      
 113   1          // adc 读取
 114   1          ADC_CONTR |= 0x40;                      //启动AD转换
 115   1          _nop_();
 116   1          _nop_();
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 3   

 117   1          while (!(ADC_CONTR & 0x20));            //查询ADC完成标志
 118   1          ADC_CONTR &= ~0x20;                     //清完成标志
 119   1          adc_val = ADC_RES<<8 | ADC_RESL;        //读取ADC结果
 120   1      
 121   1          // 计算电压毫伏
 122   1          return (u16)(3300 * (adc_val/1024.0)); // 10位adc 分辨率为 1024
 123   1      }
 124          
 125          
 126          u16 OutputCurrentRead() {
 127   1          u16 adc_val = 0;
 128   1      
 129   1          // 使能 adc
 130   1          P3M0 &= ~0x01; P3M1 &= ~0x01; // P3.0 准双向口
 131   1          P_SW2 |= 0x80;
 132   1          ADCTIM = 0x3f;                              //设置ADC内部时序
 133   1          // P_SW2 &= 0x7f;
 134   1          ADCCFG = 0x0f;                              //设置ADC时钟为系统时钟/2/16
 135   1          ADCCFG |= 0x20;                             //RESFMT 结果右对齐
 136   1          ADC_CONTR = 0x80;                           //ADC_POWER, 使能ADC模块 
 137   1          ADC_CONTR |= 0x08;                          //ADC_8, 选择通道8
 138   1      
 139   1          // adc 读取
 140   1          ADC_CONTR |= 0x40;                      //启动AD转换
 141   1          _nop_();
 142   1          _nop_();
 143   1          while (!(ADC_CONTR & 0x20));            //查询ADC完成标志
 144   1          ADC_CONTR &= ~0x20;                     //清完成标志
 145   1          adc_val = ADC_RES<<8 | ADC_RESL;        //读取ADC结果
 146   1          
 147   1          // 计算电流mA: voltage/100/0.05
 148   1          return (u16)(3300 * (adc_val/1024.0)/100/0.05); // 10位adc 分辨率为 1024
 149   1      }
 150          
 151          
 152          void init() {
 153   1          PowerIoInit();
 154   1          PowerInHold(); // 将PWR 引脚高电平，维持电池给单片机供电
 155   1          rgbInit(); // 初始化rgb灯
 156   1          // rgbWrite(0, 1, 1); // 工作指示
 157   1      
 158   1          btnInit();
 159   1          fanInit();
 160   1      
 161   1          PowerManagerAtStart();
 162   1          
 163   1          I2CInit(I2C_SLAVE_ADDRESS);
 164   1      }
 165          
 166          /* --------------------------------------------------------------
 167          
 168          1. 上电，PWR 拉高， 维持单片机供电
 169          2. 判断eeprom 的 掉电记忆，选择是否给树莓派供电
 170          3. 循环
 171              a. 按键事件 （中断/查询）
 172              b. i2c 通讯 （中断）
 173              c. 数据读取
 174              d. 风扇控制
 175              e. 充电管理
 176              f. 树莓派触发关机 （中断/查询）
 177          
 178          
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 4   

 179          灯的颜色：
 180          
 181          红色长亮 -> 待机
 182          绿色长亮 -> 输出端供电（给树莓派供电）
 183          红色闪烁 -> 电池低电提示
 184          蓝灯呼吸 -> 正在充电
 185          
 186          -------------------------------------------------------------- */
 187          #if 1
 188          void main() {
 189   1          u8 count = 0;
 190   1          u8 fan_speed = 0;
 191   1          u8 stat = 0;
 192   1          u16 battery_voltage = 0;
 193   1          u16 output_currrent = 0;
 194   1          u16 _ccr = 0;
 195   1          
 196   1          init();
 197   1          rgbWrite(0, 0, 1); // 绿+红
 198   1          EN = 1;
 199   1          // while (1);
 200   1          // rgbWrite(0, 1, 1);
 201   1          
 202   1      
 203   1          // while (1) {
 204   1          //     rgbWrite(0, 1, 1);
 205   1          //     delayMs(1000);
 206   1          //     rgbWrite(1, 0, 1);
 207   1          //     delayMs(1000);
 208   1          //     rgbWrite(1, 1, 0);
 209   1          //     delayMs(1000);
 210   1          // }
 211   1          
 212   1      
 213   1          while(1) {
 214   2              // rgbWrite(1, 1, 0);
 215   2              // if (btnIsPressed() == 1) {
 216   2              //     count++;
 217   2              //     if( count > 8) count = 0;
 218   2              //     rgbWrite(rgb_styles[count][0], rgb_styles[count][1], rgb_styles[count][2]);
 219   2              //     delayMs(200);
 220   2      
 221   2              //     // fan_speed = !fan_speed;
 222   2              //     // fanSetSpeed(fan_speed);
 223   2              // }
 224   2      
 225   2              // delayMs(20);
 226   2      
 227   2              // 电压
 228   2              battery_voltage = BatteryVoltageRead();  // mV
 229   2              i2c_buffer[0] = battery_voltage >> 8 & 0xFF;
 230   2              i2c_buffer[1] = battery_voltage & 0xFF;
 231   2      
 232   2              // 输出电流
 233   2              output_currrent = OutputCurrentRead(); // mA
 234   2              i2c_buffer[2] = output_currrent >> 8 & 0xFF;
 235   2              i2c_buffer[3] = output_currrent & 0xFF;
 236   2      
 237   2              // Power_Source, 是否电池供电
 238   2              i2c_buffer[4] = Power_Source;
 239   2      
 240   2              // CHG, 是否在给电池充电
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 5   

 241   2              i2c_buffer[5] = CHG;
 242   2      
 243   2              // 风扇速度
 244   2              // i2c_buffer[6] = fan_speed;
 245   2              i2c_buffer[6] = i2c_write_buffer[0];
 246   2              // fan_speed = i2c_write_buffer[0];
 247   2              // fan_speed = i2c_buffer[6];
 248   2      
 249   2              // fanSetSpeed(50);
 250   2              
 251   2              if (fan_speed != i2c_write_buffer[0]) {
 252   3                  fan_speed = i2c_write_buffer[0];
 253   3      
 254   3                  _ccr = ((u32)PWM_PERIOD*fan_speed/100);
 255   3                  i2c_buffer[7] = (u8)(_ccr >> 8);
 256   3                  i2c_buffer[8] = (u8)(_ccr);
 257   3      
 258   3                  fanSetSpeed(fan_speed);
 259   3              }
 260   2      
 261   2              delayMs(20);
 262   2          }
 263   1      
 264   1      }
 265          #endif
 266          
 267          #if 0
              void main()
              {
                  u8 i = 0;
              
                  init();
                  EN = 1;
                  // FAN = 1;
                  // fanSetSpeed(20);
                  while (1) {
                      for(i=0; i<100; i++) {
                          fanSetSpeed((u8)i);
                          delayMs(200);
                      }
                  }
              }
              #endif
 284          
 285          #if 1
 286          void I2C_Isr() interrupt 24
 287          {
 288   1          _push_(P_SW2);
 289   1          P_SW2 |= 0x80;
 290   1      
 291   1          if (I2CSLST & 0x40)
 292   1          {
 293   2              I2CSLST &= ~0x40;                       //处理START事件
 294   2          }
 295   1          else if (I2CSLST & 0x20)
 296   1          {
 297   2              I2CSLST &= ~0x20;                       //处理RECV事件
 298   2              if (isda)
 299   2              {
 300   3                  isda = 0;                           //处理RECV事件（RECV DEVICE ADDR）
 301   3              }
 302   2              else if (isma)
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2023 18:00:07 PAGE 6   

 303   2              {
 304   3                  isma = 0;                           //处理RECV事件（RECV MEMORY ADDR）
 305   3                  addr = I2CRXD;
 306   3                  I2CTXD = i2c_buffer[addr];
 307   3              }
 308   2              else
 309   2              {
 310   3                  //处理RECV事件（RECV DATA）
 311   3         
 312   3                  if (addr >= 0x80) {
 313   4                      i2c_write_buffer[addr-0x80] = I2CRXD;
 314   4                  }
 315   3                  
 316   3              }
 317   2          }
 318   1          else if (I2CSLST & 0x10)
 319   1          {
 320   2              I2CSLST &= ~0x10;                       //处理SEND事件
 321   2              if (I2CSLST & 0x02)
 322   2              {
 323   3                  I2CTXD = 0xff;                      //接收到NAK则停止读取数据
 324   3              }
 325   2              else
 326   2              {
 327   3                  I2CTXD = i2c_buffer[++addr];            //接收到ACK则继续读取数据
 328   3      
 329   3              }
 330   2          }
 331   1          else if (I2CSLST & 0x08)
 332   1          {
 333   2              I2CSLST &= ~0x08;                       //处理STOP事件
 334   2              isda = 1;
 335   2              isma = 1;
 336   2          }
 337   1      
 338   1          _pop_(P_SW2);
 339   1      }
 340          #endif
 341          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    542    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
