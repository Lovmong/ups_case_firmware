C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: G:\Keil_v5_c51v961\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) INCDIR(.\src;.\system) PRINT(.\List
                    -ings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*============================================================================
   2          
   3          STC8H1K28:
   4              - 32个引脚
   5          
   6          引脚连接:
   7              output:
   8                  PWR -> P3.2
   9                  EN  -> P0.0
  10              input:
  11                  BTN -> P3.3
  12                  CHG -> P0.1
  13                  POWER_SOURCE -> P1.3
  14                  RPI_STATE (pi gpio 6)-> P2.3
  15                  ALWAYS_ON -> P2.5
  16              dac:
  17                  DAC -> P1.0
  18              adc:
  19                  VBUS_3V3 -> P1.6
  20                  BT_LV_3V3 -> P1.7
  21                  BATTERY_CURRENT -> P0.2
  22                  OUTPUT_CURRENT -> P0.3
  23              i2c:
  24                  SDA -> P1.4
  25                  SCL -> P1.5
  26              rgb: (PWMB)
  27                  LED_B -> PWM5 -> P2.0
  28                  LED_G -> PWM6 -> P2.1
  29                  LED_R -> PWM7 -> P2.2
  30              fan: (PWMA)
  31                  FAN -> PWM3P_2 -> P2.4
  32              uart:
  33                  TXD -> P3.1
  34                  RXD -> P3.0
  35          
  36          ==============================================================================*/
  37          
  38          #include "stc8h.h"
  39          #include "intrins.h"
  40          
  41          #include "types.h"
  42          #include "delay.h"
  43          
  44          #include "btn.h"
  45          #include "rgb.h"
  46          #include "fan.h"
  47          
  48          #include "power.h"
  49          
  50          #include "test.h"
  51          /*---------------------------------------------------------------
  52              i2c: (默认i2c1)
  53                  SDA -> P1.4
  54                  SCL -> P1.5
C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 2   

  55          
  56              STC8H 系列 i2c 的中断号为 24
  57          ---------------------------------------------------------------*/
  58          #define I2C_SLAVE_ADDRESS 0x5A
  59          #define SDA P14
  60          #define SCL P15
  61          
  62          bit isda; // 设备地址标志
  63          bit isma; // 存储地址标志
  64          u8 addr;  // i2c buffer address
  65          
  66          u8 data_buffer[] = {
  67              0, // 电池电压高位 mV
  68              0, // 电池电压低位 mV
  69              0, // 输出电流高位 mA
  70              0, // 输出电流低位 mA
  71              0, // Power_Source, 0 usb 供电，1 电池供电
  72              0, // CHG, 0 电池未充电， 1 正在充电
  73              0, // 风扇速度 0 ~ 100
  74              0, // PWM CCR1H
  75              0, // PWM CCR1H
  76          };
  77          
  78          u8 control_buffer[] = {
  79              0, // 风扇速度 0 ~ 100
  80          };
  81          
  82          // ------------ I2C_Init------------------------
  83          void I2C_Init()
  84          {
  85   1          P1M0 &= ~0x30;
  86   1          P1M1 &= ~0x30; // P1.4, P1.5 准双向口
  87   1      
  88   1          P_SW2 |= 0x80; // 使能扩展寄存器(XFR)访问
  89   1          // P_SW2 |= 0x10;                              //切换i2c引脚
  90   1      
  91   1          I2CCFG = 0x81;                              // 使能I2C从机模式
  92   1          I2CSLADR = (I2C_SLAVE_ADDRESS << 1) & 0xFE; // 设置从机设备地址, MA=0
  93   1          I2CSLST = 0x00;                             // 复位从机状态寄存器
  94   1          I2CSLCR = 0x78;                             // 使能从机模式中断
  95   1          EA = 1;                                     // 使能全局中断
  96   1      
  97   1          isda = 1; // 用户变量初始化
  98   1          isma = 1;
  99   1          addr = 0;
 100   1          I2CTXD = data_buffer[addr];
 101   1      }
 102          
 103          #if 1 // ------------ I2C_Isr (中断号 24)------------------------
 104          void I2C_Isr() interrupt 24
 105          {
 106   1          _push_(P_SW2);
 107   1          P_SW2 |= 0x80;
 108   1      
 109   1          // --------- START事件 ---------
 110   1          if (I2CSLST & 0x40)
 111   1          {
 112   2              I2CSLST &= ~0x40;
 113   2          }
 114   1          // --------- RECV事件 ---------
 115   1          else if (I2CSLST & 0x20)
 116   1          {
C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 3   

 117   2              I2CSLST &= ~0x20;
 118   2              if (isda)
 119   2              { // 处理RECV事件（RECV DEVICE ADDR）
 120   3                  isda = 0;
 121   3              }
 122   2              else if (isma)
 123   2              { // 处理RECV事件（RECV MEMORY ADDR）
 124   3                  isma = 0;
 125   3                  addr = I2CRXD;
 126   3                  I2CTXD = data_buffer[addr];
 127   3              }
 128   2              else
 129   2              { // 处理RECV事件（RECV DATA）
 130   3                  if (addr >= 0x80)
 131   3                  {
 132   4                      control_buffer[addr - 0x80] = I2CRXD;
 133   4                  }
 134   3              }
 135   2          }
 136   1          // --------- SEND事件 ---------
 137   1          else if (I2CSLST & 0x10)
 138   1          {
 139   2              I2CSLST &= ~0x10;
 140   2              if (I2CSLST & 0x02)
 141   2              { // 接收到NAK则停止读取数据
 142   3                  I2CTXD = 0xff;
 143   3              }
 144   2              else
 145   2              { // 接收到ACK则继续读取数据
 146   3                  I2CTXD = data_buffer[++addr];
 147   3              }
 148   2          }
 149   1          // ---------STOP事件 ---------
 150   1          else if (I2CSLST & 0x08)
 151   1          {
 152   2              I2CSLST &= ~0x08;
 153   2              isda = 1;
 154   2              isma = 1;
 155   2          }
 156   1      
 157   1          _pop_(P_SW2);
 158   1      }
 159          #endif
 160          
 161          //  ------------------ Init ------------------
 162          void init()
 163          {
 164   1          PowerIoInit();
 165   1          PowerInHold(); // 将PWR 引脚高电平，维持电池给单片机供电
 166   1          PowerManagerAtStart();
 167   1      
 168   1          rgbInit(); // 初始化rgb灯
 169   1          // rgbWrite(0, 0, 0); // 工作指示
 170   1      
 171   1          // btnInit();
 172   1          // fanInit();
 173   1          AdcInit();
 174   1          I2C_Init();
 175   1      }
 176          
 177          /* --------------------- main ---------------------
 178          1. 上电，PWR 拉高， 维持单片机供电
C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 4   

 179          2. 判断eeprom 的 掉电记忆，选择是否给树莓派供电
 180          3. 循环
 181              a. 按键事件 （中断/查询）
 182              b. i2c 通讯 （中断）
 183              c. 数据读取
 184              d. 风扇控制
 185              e. 充电管理
 186              f. 树莓派触发关机 （中断/查询）
 187          
 188          灯的颜色：
 189          
 190          红色长亮 -> 待机
 191          绿色长亮 -> 输出端供电（给树莓派供电）
 192          红色闪烁 -> 电池低电提示
 193          蓝灯呼吸 -> 正在充电
 194          
 195          -------------------------------------------------------------- */
 196          #if 1
 197          void main()
 198          {
 199   1          u16 count = 0;
 200   1          u8 fan_speed = 0;
 201   1          u8 stat = 0;
 202   1          u16 battery_voltage = 0;
 203   1          u16 output_currrent = 0;
 204   1          u16 _ccr = 0;
 205   1      
 206   1          init();
 207   1      
 208   1          // rgbTest();
 209   1          // btnTest();
 210   1          // fanTest();
 211   1          // fanSetSpeed(50);
 212   1      
 213   1          // P2M0 &= ~0x10; P2M1 &= ~0x10;    // P2.4 准双向口
 214   1          // P2M0 |= 0x10; P2M1 &= ~0x10;
 215   1          // FAN = 0;
 216   1      
 217   1          while (1)
 218   1          {
 219   2              // P1M0 &= ~0x80; P1M1 &= ~0x80;
 220   2      
 221   2              // AdcInit();
 222   2      
 223   2              // // ADCCFG |= 0x20;                             //RESFMT 结果右对齐
 224   2              // ADCCFG = 0x00;                             //RESFMT 结果左对齐
 225   2              // ADC_CONTR &=  0xF0;                     //复位通道
 226   2              // ADC_CONTR |= 0x07;                   //选择adc通道
 227   2      
 228   2              // // adc 读取
 229   2              // ADC_CONTR |= 0x40;                      //启动AD转换
 230   2              // _nop_();
 231   2              // _nop_();
 232   2              // while (!(ADC_CONTR & 0x20));            //等待ADC完成
 233   2              // ADC_CONTR &= ~0x20;                     //清完成标志
 234   2              // // adc_val = ADC_RES<<8 | ADC_RESL;        //读取ADC结果
 235   2              // // battery_voltage = (ADC_RES << 2)| (ADC_RESL >> 6);
 236   2      
 237   2              // data_buffer[0] = ADC_RES;
 238   2              // data_buffer[1] = ADC_RESL;
 239   2      
 240   2              battery_voltage = BatteryVoltageRead(); // mV
C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 5   

 241   2              data_buffer[0] = battery_voltage >> 8 & 0xFF;
 242   2              data_buffer[1] = battery_voltage & 0xFF;
 243   2      
 244   2              output_currrent = BatteryCurrentRead(); // mA
 245   2              data_buffer[2] = output_currrent >> 8 & 0xFF;
 246   2              data_buffer[3] = output_currrent & 0xFF;
 247   2              delayMs(20);
 248   2          }
 249   1      
 250   1          // while(1) {
 251   1          // rgbWrite(1, 1, 0);
 252   1          // if (btnIsPressed() == 1) {
 253   1          //     count++;
 254   1          //     if( count > 8) count = 0;
 255   1          //     rgbWrite(rgb_styles[count][0], rgb_styles[count][1], rgb_styles[count][2]);
 256   1          //     delayMs(200);
 257   1      
 258   1          //     // fan_speed = !fan_speed;
 259   1          //     // fanSetSpeed(fan_speed);
 260   1          // }
 261   1      
 262   1          // delayMs(20);
 263   1      
 264   1          //     // 电压
 265   1          //     battery_voltage = BatteryVoltageRead();  // mV
 266   1          //     data_buffer[0] = battery_voltage >> 8 & 0xFF;
 267   1          //     data_buffer[1] = battery_voltage & 0xFF;
 268   1      
 269   1          //     // 输出电流
 270   1          //     output_currrent = OutputCurrentRead(); // mA
 271   1          //     data_buffer[2] = output_currrent >> 8 & 0xFF;
 272   1          //     data_buffer[3] = output_currrent & 0xFF;
 273   1      
 274   1          //     // Power_Source, 是否电池供电
 275   1          //     data_buffer[4] = Power_Source;
 276   1      
 277   1          //     // CHG, 是否在给电池充电
 278   1          //     data_buffer[5] = CHG;
 279   1      
 280   1          //     // 风扇速度
 281   1          //     // data_buffer[6] = fan_speed;
 282   1          //     data_buffer[6] = control_buffer[0];
 283   1          //     // fan_speed = control_buffer[0];
 284   1          //     // fan_speed = data_buffer[6];
 285   1      
 286   1          //     // fanSetSpeed(50);
 287   1      
 288   1          //     if (fan_speed != control_buffer[0]) {
 289   1          //         fan_speed = control_buffer[0];
 290   1      
 291   1          //         _ccr = ((u32)_PWMA_PERIOD*fan_speed/100);
 292   1          //         data_buffer[7] = (u8)(_ccr >> 8);
 293   1          //         data_buffer[8] = (u8)(_ccr);
 294   1      
 295   1          //         fanSetSpeed(fan_speed);
 296   1          //     }
 297   1      
 298   1          //     delayMs(20);
 299   1          // }
 300   1      }
 301          #endif

C51 COMPILER V9.60.7.0   MAIN                                                              09/07/2023 18:42:22 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    494    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
