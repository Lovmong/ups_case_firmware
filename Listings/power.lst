C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE POWER
OBJECT MODULE PLACED IN .\Objects\power.obj
COMPILER INVOKED BY: G:\Keil_v5_c51v961\C51\BIN\C51.EXE src\power.c OPTIMIZE(8,SPEED) INCDIR(.\src;.\system) PRINT(.\Lis
                    -tings\power.lst) TABS(2) OBJECT(.\Objects\power.obj)

line level    source

   1          #include "power.h"
   2          
   3          // =========================== åˆå§‹åŒ– ==================================
   4          void PowerIoInit()
   5          {
   6   1          // output æ¨æŒ½è¾“å‡º
   7   1          P0M0 |= 0x01;
   8   1          P0M1 &= ~0x01; // EN, P0.0 æ¨æŒ½è¾“å‡º
   9   1          P3M0 |= 0x04;
  10   1          P3M1 &= ~0x04; // PWR, P3.2 æ¨æŒ½è¾“å‡º
  11   1          // input é«˜é˜»è¾“å…¥
  12   1          P0M0 &= ~0x02;
  13   1          P0M1 |= 0x02; // CHG, P0.1 é«˜é˜»è¾“å…¥
  14   1          P1M0 &= ~0x08;
  15   1          P1M1 |= 0x08; // Power_Source, P1.3 é«˜é˜»è¾“å…¥
  16   1          P2M0 &= ~0x08;
  17   1          P2M1 |= 0x08; // RPI_STATE, P2.3 é«˜é˜»è¾“å…¥
  18   1          P2M0 &= ~0x20;
  19   1          P2M1 |= 0x20; // ALWAYS_ON, P2.5 é«˜é˜»è¾“å…¥
  20   1          // dac æ¨æŒ½è¾“å‡º
  21   1          P1M0 |= 0x01;
  22   1          P1M1 &= ~0x01; // DAC, P1.0 æ¨æŒ½è¾“å‡º
  23   1          // adc
  24   1          P1M0 &= ~0x40;
  25   1          P1M1 |= 0x40; // VBUS_3V3, P1.6 é«˜é˜»è¾“å…¥
  26   1          P1M0 &= ~0x80;
  27   1          P1M1 |= 0x80; // BT_LV_3V3, P1.7 é«˜é˜»è¾“å…¥
  28   1          P0M0 &= ~0x04;
  29   1          P0M1 |= 0x04; // BATTERY_CURRENT, P0.2 é«˜é˜»è¾“å…¥
  30   1          P0M0 &= ~0x08;
  31   1          P0M1 |= 0x08; // OUTPUT_CURRENT, P0.3 é«˜é˜»è¾“å…¥
  32   1      }
  33          
  34          /** ç»´æŒç”µæ± ç»™å•ç‰‡æœºä¾›ç”µ */
  35          void PowerInHold()
  36          {
  37   1          P3M0 |= 0x04;
  38   1          P3M1 &= ~0x04; // PWR, P3.2 æ¨æŒ½è¾“å‡º
  39   1          PWR = 1;       // ç»´æŒé«˜ç”µå¹³ï¼Œ ç»´æŒç»™å•ç‰‡æœºä¾›ç”µ
  40   1      }
  41          
  42          // ======================== 5V è¾“å‡ºç›¸å…³ ==================================
  43          
  44          /** æ‰“å¼€5vè¾“å‡º,è®°å¿†çŠ¶æ€ */
  45          void PowerOutOpen()
  46          {
  47   1          P0M0 |= 0x01;
  48   1          P0M1 &= ~0x01; // EN, P0.0 æ¨æŒ½è¾“å‡º
  49   1          EN = 0;
  50   1          IapErase(POWER_MEMORY_ADDR);         // æ“¦é™¤EEPROMæ‰‡åŒº
  51   1          IapProgram(POWER_MEMORY_ADDR, 0x02); // è®°å¿†è¾“å‡ºæ‰“å¼€
  52   1      }
  53          
  54          /** æ‰“å¼€5vè¾“å‡º,è®°å¿†çŠ¶æ€ */
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 2   

  55          void PowerOutClose()
  56          {
  57   1          P0M0 |= 0x01;
  58   1          P0M1 &= ~0x01; // EN, P0.0 æ¨æŒ½è¾“å‡º
  59   1          EN = 0;
  60   1          IapErase(POWER_MEMORY_ADDR);         // æ“¦é™¤EEPROMæ‰‡åŒº
  61   1          IapProgram(POWER_MEMORY_ADDR, 0x01); // è®°å¿†è¾“å‡ºå…³é—­
  62   1      }
  63          
  64          /** ä¸Šç”µæ—¶æ¢å¤ç”µæºè®°å¿† */
  65          void PowerManagerAtStart()
  66          {
  67   1          /*å½“ ALWAYS_ON ä¸ºæœ‰æ•ˆæ—¶ï¼ˆä½ç”µå¹³ï¼‰æ—¶ï¼Œpower è¾“å‡º(),
  68   1           *å¦åˆ™ï¼š
  69   1           *    è¯»å–eepromå€¼
  70   1           *    å¦‚æœå€¼ä¸º 0x01ï¼Œpowerä¸è¾“å‡º
  71   1           *    å¦‚æœå€¼ä¸º 0x02ï¼Œpowerä¸è¾“å‡º
  72   1           *    å¦‚æœå€¼é”™è¯¯ï¼Œé»˜è®¤powerä¸è¾“å‡º
  73   1           */
  74   1          char stat = 0;
  75   1      
  76   1          P1M0 |= 0x80;
  77   1          P1M1 &= ~0x80; // ALWAYS_ON, P1.7 é«˜é˜»è¾“å…¥
  78   1          P3M0 |= 0x10;
  79   1          P3M1 &= ~0x10; // EN, P3.4 æ¨æŒ½è¾“å‡º
  80   1      
  81   1          if (ALWAYS_ON == 0)
  82   1          {
  83   2              delayUs(500); // æ¶ˆæŠ–
  84   2              if (ALWAYS_ON == 0)
  85   2              {
  86   3                  EN = 1; // powerè¾“å‡º
  87   3                  return;
  88   3              }
  89   2          }
  90   1      
  91   1          stat = IapRead(POWER_MEMORY_ADDR);
  92   1          // EEPROM çš„å†™æ“ä½œåªèƒ½å°†å­—èŠ‚ä¸­çš„ 1 å†™ä¸º 0ï¼Œå½“éœ€è¦å°†å­—èŠ‚ä¸­çš„ 0 å†™ä¸º 1ï¼Œåˆ™å¿…é
             -¡»æ‰§è¡Œæ‰‡åŒº æ“¦é™¤æ“ä½œã€‚
  93   1          switch (stat)
  94   1          {
  95   2          case 0x01: // å…³é—­è¾“å‡º
  96   2              PowerOutClose();
  97   2              break;
  98   2          case 0x02: // å¼€å¯è¾“å‡º
  99   2              PowerOutOpen();
 100   2              break;
 101   2          default: // é»˜è®¤powerä¸è¾“å‡º
 102   2              PowerOutClose();
 103   2              break;
 104   2          }
 105   1      }
 106          
 107          // ========================  adcè¯»å€¼ç›¸å…³ ==================================
 108          /* ------------------------------------------------------------
 109          ADC_CONTR: ADC_CONTR ADC æ§åˆ¶å¯„å­˜å™¨
 110                  7           6            5          4          3 2 1 0
 111                  ADC_POWER  ADC_START   ADC_FLAG    ADC_EPWMT   ADC_CHS[3:0]
 112              ADC_CHS[3:0]ï¼š é€šé“é€‰æ‹©
 113          
 114          ADC_RESï¼š ADC è½¬æ¢ç»“æœé«˜ä½å¯„å­˜å™¨
 115          ADC_RESLï¼š ADC è½¬æ¢ç»“æœä½ä½å¯„å­˜å™¨
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 3   

 116          ADCCFGï¼šADC é…ç½®å¯„å­˜å™¨
 117                  5
 118                 RESFMT
 119          ADCTIM: ADC æ—¶åºæ§åˆ¶å¯„å­˜å™¨
 120          
 121          ------------------------------------------------------------ */
 122          /** åˆå§‹åŒ–adc */
 123          void AdcInit()
 124          {
 125   1          P_SW2 |= 0x80;    // ä½¿èƒ½æ‰©å±•å¯„å­˜å™¨(XFR)è®¿é—®
 126   1          ADCTIM = 0x3f;    // è®¾ç½®ADCå†…éƒ¨æ—¶åº
 127   1          ADCCFG = 0x0f;    // è®¾ç½®ADCæ—¶é’Ÿä¸ºç³»ç»Ÿæ—¶é’Ÿ/2/16
 128   1          ADCCFG |= 0x20;   // RESFMT ç»“æœå³å¯¹é½
 129   1          ADC_CONTR = 0x80; // ADC_POWER, ä½¿èƒ½ADCæ¨¡å—
 130   1      }
 131          
 132          /** adcè¯»å€¼ */
 133          u16 AdcRead(u8 channel)
 134          {
 135   1          u16 adc_val = 0;
 136   1      
 137   1          ADC_CONTR &= 0xF0;    // å¤ä½é€šé“
 138   1          ADC_CONTR |= channel; // é€‰æ‹©adcé€šé“
 139   1      
 140   1          // adc è¯»å–
 141   1          ADC_CONTR |= 0x40; // å¯åŠ¨ADè½¬æ¢
 142   1          _nop_();
 143   1          _nop_();
 144   1          while (!(ADC_CONTR & 0x20))
 145   1              ;                              // ç­‰å¾…ADCå®Œæˆ
 146   1          ADC_CONTR &= ~0x20;                // æ¸…å®Œæˆæ ‡å¿—
 147   1          adc_val = ADC_RES << 8 | ADC_RESL; // è¯»å–ADCç»“æœ
 148   1          // è®¡ç®—ç”µå‹æ¯«ä¼
 149   1          return (u16)(3300 * (adc_val / 1024.0)); // 10ä½adc åˆ†è¾¨ç‡ä¸º 1024
 150   1      }
 151          
 152          /** è¯»å–USBè¾“å…¥ç”µå‹(mV)*/
 153          u16 UsbVoltageRead()
 154          {
 155   1          // VBUS_3V3 -> ADC6 -> P1.6
 156   1          P1M0 &= ~0x40;
 157   1          P1M1 |= 0x40; // VBUS_3V3, P1.6 é«˜é˜»è¾“å…¥
 158   1          // AdcInit();                              // åˆå§‹åŒ–adc
 159   1          return AdcRead(6); // è¿”å›è¯»å€¼
 160   1      }
 161          
 162          /** è¯»å–Batteryè¾“å‡ºç”µå‹(mV) */
 163          u16 BatteryVoltageRead()
 164          {
 165   1          // BT_LV_3V3 -> ADC7 -> P1.7
 166   1          P1M0 &= ~0x80;
 167   1          P1M1 |= 0x80; // BT_LV_3V3, P1.7 é«˜é˜»è¾“å…¥
 168   1          // AdcInit();                              // åˆå§‹åŒ–adc
 169   1          return (u16)(AdcRead(BATTERY_VOLTAGE_CHANNEL) * BATTERY_VOLTAGE_GAIN); // è¿”å›è¯»å€¼
 170   1      }
 171          
 172          /** è¯»å–Batteryè¾“å‡ºç”µæµ(mA)*/
 173          u16 BatteryCurrentRead()
 174          {
 175   1          // BATTERY_CURRENT -> ADC10 -> P0.2
 176   1          P0M0 &= ~0x04;
 177   1          P0M1 |= 0x04; // BATTERY_CURRENT, P0.2 é«˜é˜»è¾“å…¥
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 4   

 178   1          // AdcInit();                              // åˆå§‹åŒ–adc
 179   1          return (u16)((AdcRead(10) - 1250) / 0.05 / 100); // è¿”å›è¯»å€¼ ç”µæµ = ï¼ˆæµ‹é‡ç”µå‹-1.25Vï¼‰/100
             -/0.05
 180   1      }
 181          
 182          /** è¯»å–Outputè¾“å‡ºç”µæµ(mA)*/
 183          u16 OutputCurrentRead()
 184          {
 185   1          // OUTPUT_CURRENT -> ADC11 -> P0.3
 186   1          P0M0 &= ~0x08;
 187   1          P0M1 |= 0x08;                             // OUTPUT_CURRENT, P0.3 é«˜é˜»è¾“å…¥
 188   1          AdcInit();                                // åˆå§‹åŒ–adc
 189   1          return (u16)((AdcRead(11)) / 0.05 / 100); // è¿”å›è¯»å€¼ ç”µæµ = æµ‹é‡ç”µå‹4/100/0.05
 190   1      }
 191          
 192          // ======================== ç”µæ± å……ç”µç›¸å…³ ==================================
 193          
 194          /** ç”µæ± å……ç”µç®¡ç† */
 195          void ChargeManager()
 196          {
 197   1          u16 use_vol, dac_vol;
 198   1          /* å¦‚æœæ­£åœ¨å……ç”µï¼Œæ ¹æ®usbè¾“å…¥ç”µå‹ï¼Œä½¿ç”¨pidè°ƒèŠ‚dacç”µå‹ï¼Œè¿›è€Œè°ƒèŠ‚å……ç”µç”µæµ
 199   1           * å¦åˆ™ï¼Œdacè¾“å‡º0
 200   1           */
 201   1          if (CHG)
 202   1          {
 203   2              use_vol = UsbVoltageRead();
 204   2              dac_vol = pidCalculate(use_vol);
 205   2              setDac(dac_vol);
 206   2          }
 207   1          else
 208   1          {
 209   2              setDac(0);
 210   2          }
 211   1      }
 212          
 213          /** dacåˆå§‹åŒ– */
 214          void dacInit()
 215          {
 216   1          /* DAC -> PWM1P -> P1.0
 217   1           * æ³¨æ„ dac å’Œ fan éƒ½ä½¿ç”¨ PWMA, åˆå§‹åŒ–æ—¶ é¢„åˆ†é¢‘ å’Œ è‡ªåŠ¨é‡è£…è½½å€¼è¦ä¸€è‡´ï¼Œæˆ–è€…ä
             -»…åˆå§‹åŒ–ä¸€æ¬¡
 218   1           */
 219   1          P1M0 |= 0x01;
 220   1          P1M1 &= ~0x01; // DAC, P1.0 æ¨æŒ½è¾“å‡º
 221   1      
 222   1          P_SW2 |= 0x80; // ä½¿èƒ½æ‰©å±•å¯„å­˜å™¨(XFR)è®¿é—®
 223   1      
 224   1          PWMA_CCER1 = 0x00; // å†™CCMRxå‰å¿…é¡»å…ˆæ¸…é›¶CCERxå…³é—­é€šé“
 225   1          PWMA_CCMR1 = 0x68; // è®¾ç½®PWM1è¾“å‡ºæ¨¡å¼ 1, ä½¿èƒ½é¢„è£…è½½åŠŸèƒ½
 226   1          PWMA_CCER1 = 0x01; // ä½¿èƒ½PWM1Pé€šé“, ææ€§ä¸º é«˜ç”µå¹³æœ‰æ•ˆ
 227   1      
 228   1          PWMA_PSCRH = (u8)((_PWMA_PSCR - 1) >> 8); // è®¾ç½®PWMAé¢„åˆ†é¢‘
 229   1          PWMA_PSCRL = (u8)(_PWMA_PSCR - 1);
 230   1          PWMA_ARRH = (u8)((_PWMA_PERIOD - 1) >> 8); // è®¾ç½®å‘¨æœŸæ—¶é—´ï¼Œ PWMA_ARRè‡ªåŠ¨é‡è£…å€¼
 231   1          PWMA_ARRL = (u8)(_PWMA_PERIOD - 1);
 232   1      
 233   1          PWMA_CCR1H = (u8)(0 >> 8); // åˆå§‹åŒ–PWM1å ç©ºæ¯”æ—¶é—´
 234   1          PWMA_CCR1L = (u8)(0);
 235   1      
 236   1          PWMA_ENO |= 0x01; // ä½¿èƒ½PWM1Pè¾“å‡º
 237   1      
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 5   

 238   1          PWMA_BKR = 0x80; // ä½¿èƒ½PWMAä¸»è¾“å‡º
 239   1          PWMA_CR1 = 0x01; // ä½¿èƒ½PWMAè®¡æ•°å™¨ï¼Œå¼€å§‹è®¡æ—¶, (00 è¾¹æ²¿å¯¹é½æ¨¡å¼)
 240   1      }
 241          
 242          /** è®¾ç½®dacè¾“å‡ºç”µå‹ï¼ˆmVï¼‰*/
 243          void setDac(u16 voltage)
 244          {
 245   1          u16 ccr = 0;
 246   1          ccr = ((u32)_PWMA_PERIOD * voltage / 3300); // æ»¡çº§ç”µå‹3.3V
 247   1      
 248   1          P_SW2 |= 0x80;               // ä½¿èƒ½æ‰©å±•å¯„å­˜å™¨(XFR)è®¿é—®
 249   1          PWMA_CCR1H = (u8)(ccr >> 8); // è®¾ç½®PWM1å ç©ºæ¯”
 250   1          PWMA_CCR1L = (u8)(ccr);
 251   1      }
 252          
 253          /** pidè®¡ç®—
 254           * è¾“å…¥ï¼šå……ç”µå£(usb)ç”µå‹ï¼ˆmVï¼‰
 255           * è¿”å›ï¼šå……ç”µç”µæµè°ƒèŠ‚ç”µå‹ï¼ˆmVï¼‰
 256           */
 257          int lastError = 0;
 258          long sumError = 0;
 259          
 260          u16 pidCalculate(u16 current_vol)
 261          {
 262   1          u16 error, dError, output;
 263   1      
 264   1          error = current_vol - targetVoltage; // åå·®
 265   1          sumError += error;                   // ç§¯åˆ†
 266   1          if (sumError < -330000)
 267   1              sumError = -330000; // ç§¯åˆ†é™å¹…
 268   1          else if (sumError > 330000)
 269   1              sumError = 330000;
 270   1          dError == error - lastError; // å¾®åˆ†
*** WARNING C275 IN LINE 270 OF src\power.c: expression with possibly no effect
 271   1          lastError = error;
 272   1      
 273   1          output = kp * error + ki * sumError + kd * dError;
 274   1          if (output < 0)
 275   1              output = 0;
 276   1          else if (output > maxValue)
 277   1              output = maxValue;
 278   1      
 279   1          return output;
 280   1      }
 281          
 282          // ========================  ç”µæ± ç”µé‡ç›¸å…³ ==================================
 283          #define CheckPoint0 6800 // ç”µæ±  7% ç”µé‡æµ‹é‡ç‚¹ç”µå‹
 284          #define CheckPoint1 6500 // ç”µæ±  3% ç”µé‡æµ‹é‡ç‚¹ç”µå‹
 285          #define CheckPoint3 6200 // ç”µæ±  0% ç”µé‡æµ‹é‡ç‚¹ç”µå‹
 286          #define MaxVoltage 8400  // mV 100% æ—¶ç”µå‹
 287          
 288          u16 MaxCapacity = 2000;       // mAh ç”µæ± æœ€å¤§å®¹é‡
 289          u16 RemainingCapacity = 2000; // mAh ç”µæ± å‰©ä½™å®¹é‡
 290          u16 BatteryIR = 50;           // mOhm ç”µæ± å†…é˜»
 291          
 292          /** è®¡ç®—ç”µæ± å†…é˜» */
 293          u16 calculateBatteryIR()
 294          {
 295   1          /* é€šè¿‡æµ‹é‡å¼€å¯è´Ÿè½½åçš„å‰åå‹å·®å’Œç”µæµå·®ï¼Œè®¡ç®—å†…é˜»
 296   1           * IR = (U2 - U1)/(I2 - I1)
 297   1           */
 298   1          u16 U1, U2, I1, I2, IR;
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 6   

 299   1      
 300   1          // ---- è®¡ç®—å†…é˜»
 301   1          // closeRL(); // å…³é—­è´Ÿè½½ç”µé˜»
 302   1          EN = 0;
 303   1          U1 = (u16)BatteryVoltageRead(); // mV
 304   1          I1 = (u16)BatteryCurrentRead(); // mAh
 305   1      
 306   1          // openRL(); // æ‰“å¼€è´Ÿè½½ç”µé˜»
 307   1          EN = 1;
 308   1          U2 = (u16)BatteryVoltageRead();
 309   1          I2 = (u16)BatteryCurrentRead();
 310   1      
 311   1          IR = 1000 * (u32)(U2 - U1) / (I2 - I1); // mOhm
 312   1      
 313   1          BatteryIR = IR;
 314   1          return IR;
 315   1      }
 316          
 317          /** ä¸Šç”µæ—¶åˆå§‹åŒ–ç”µæ± å‰©ä½™å®¹é‡ */
 318          void RemainingCapacityInit()
 319          {
 320   1          /* æ ¹æ®ç”µå‹ä¸ç”µå®¹çš„å¯¹åº”å…³ç³»ï¼Œç²—ç•¥ä¼°ç®—ç”µæ± ç”µå‹
 321   1      
 322   1          */
 323   1          u16 vol, current;
 324   1      
 325   1          vol = BatteryVoltageRead();
 326   1          current = BatteryCurrentRead();
 327   1      }
 328          
 329          /** æ›´æ–°ç”µé‡ç™¾åˆ†æ¯”
 330           * è¿”å› ç™¾åˆ†æ¯” 0 ~ 100
 331           */
 332          u8 UpdateBatteryPercentage()
 333          {
 334   1      }
*** WARNING C173 IN LINE 334 OF src\power.c: missing return-expression
 335          
 336          /* ----- ä½ç”µé‡æ—¶ -----
 337          
 338          */
 339          void PowerManagerInLowBattery()
 340          {
 341   1      }
 342          
 343          /* ----- ç”µæºæ•°æ®è¯»å– -----
 344          
 345          */
 346          void PowerMonitor()
 347          {
 348   1      }
*** WARNING C290 IN LINE 334 OF src\power.c: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    779    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.60.7.0   POWER                                                             09/07/2023 18:41:59 PAGE 7   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
